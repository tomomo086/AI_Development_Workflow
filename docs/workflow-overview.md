# ワークフロー概要

※本ドキュメントはエンジニア未経験からAI(LLM)活用を実践する中で編み出した、独自の開発ワークフローを体系化したものです。理論だけでなく、個人の試行錯誤から生まれたリアルな知見を共有します。

## 📊 AI統合ワークフロー図（Gemini生成）

![Gemini生成AI統合ワークフロー図](assets/screenshots/ss_43.png)

*※このフロー図はGeminiで生成されたもので、実際の開発ワークフローを視覚化しています。*

## 各AI(LLM)ツールの主観的な利点・デメリット（実践的視点）

- **Claude Desktop**
  - 利点: チャットUIで視認性が高く直感的に対話可能／MCPによる拡張性で万能性あり／ZapierMCP連携でGoogleドライブ等にスマホからもアクセスしやすい
  - デメリット: 処理速度がやや遅い／ファイル操作の現状が分かりにくい／途中停止は強制ストップが必要

- **ClaudeCode**
  - 利点: CLIベースで処理が速い／操作中のファイルが可視化される／途中で許可を求めてくるので進捗管理しやすい
  - デメリット: Cursorほど細かな調整ができない／CLIは初心者には複雑／視覚的に分かりにくい

- **Cursor**
  - 利点: Reject/Acceptによる細かな段階的修正／複数AI(LLM)を使い分け可能／リアルタイムエラー検出や自動フォーマットなど細やかな品質向上が可能
  - デメリット: ClaudeCodeほどのスピード感はない／AI(LLM)の提案精度はプロンプトや文脈に依存する場合あり

※上記はすべてtomomo086（エンジニア未経験から実践で習得）の主観的な感想です。

### ⚠️ 重要な注意事項
**AI(LLM)全般について**: AI(LLM)が教えてくれることを鵜呑みにせず、批判的思考を忘れずに自分でも調べてAI(LLM)の舵を取ることが、正しい答えにたどり着く方法だと思いました。AI(LLM)は強力なツールですが、人間の判断と検証が不可欠です。

## ワークフローの核心コンセプト
私のワークフローの核心は、アイデア出しと自動化の『Claude Desktop』、高速な実装の『ClaudeCode』、そして**最終的な品質向上の『Cursor』**という3つのツールを連携させることです。この『適材適所』の使い分けにより、開発プロセス全体を効率化します。

## 実践的AI統合開発ワークフロー

このドキュメントでは、Claude統合環境での実際の開発ワークフローを説明します。

## 🔄 開発ワークフロー

### 1. アイデア出し・方向性決定

**このステップのゴール**: プロジェクトの全体像を把握し、実現可能な開発戦略を策定する。開発の方向性を明確にして、後続の実装作業を効率化する。

**使用ツール**: Claude Desktop, Grok3, FilesystemMCP

- **Claude Desktop**を使用して大まかな方向性を決定
- 必要に応じて**Grok3**も併用してアイデアを発展
- **FilesystemMCP**でフォルダ・ファイルの初期作成も実行
- 開発前の戦略立案と要件整理

### 2. 仕様書作成

**このステップのゴール**: アイデアを具体的な実装可能な仕様に落とし込み、ClaudeCodeが効率的に処理できる形で情報を整理する。

**使用ツール**: テキストエディタ, Claude Desktop

- ローカルの`dev/projects`フォルダ内に仕様書を作成
- ClaudeCodeが理解しやすい形式で情報を整理
- 実装に必要な詳細情報を体系的にまとめる

### 3. 実装・フォルダ構造作成

**このステップのゴール**: 仕様書を基にプロジェクトの骨格となるフォルダ構造とファイルを高速で生成し、実装の基盤を構築する。

**使用ツール**: ClaudeCode, PowerShell

- **PowerShell**で`projects`フォルダに移動
- **ClaudeCode**を起動して仕様書を参照
- 仕様書の内容を元にフォルダ構造を自動生成
- 段階的なタスク実行と進捗管理

### 4. Cursorでの詳細編集・品質向上・最適化作業

**このステップのゴール**: ClaudeCodeが生成したコードの骨格に、AIアシスタントの力を借りて肉付けを行い、品質と完成度をプロレベルまで引き上げる。

**使用ツール**: Cursor, GitHub Desktop

- **GitHub Desktop**でローカルリポジトリの状態を確認
- **Cursor**でプロジェクトを開いて詳細編集を実行
  - **AI(LLM)アシスタント機能**を活用したコード品質向上
  - **リアルタイムエラー検出**と修正提案
  - **自動フォーマット**とコーディング規約適用
  - **インテリセンス機能**による効率的なコーディング
- **AI(LLM)アシスタント**を使用してMITライセンスファイルを自動生成
- 写真配置ファイルの作成とファイル名の最適化
- 段階的なファイル管理とコミット準備
- **コードレビュー**: AI(LLM)アシスタントによる自動コードレビュー
- **パフォーマンス最適化**: ボトルネック検出と改善提案
- **セキュリティチェック**: 脆弱性検出と修正提案
- **ドキュメント整備**: README、コメント、API文書の自動生成・更新
- **テスト強化**: ユニットテスト、統合テストの自動生成
- **依存関係管理**: パッケージ更新とセキュリティ修正
- **Reject/Accept機能**: 細かな段階的修正による高品質なコード生成
- **複数AI(LLM)使い分け**: 用途に応じてClaude、Gemini、その他のAI(LLM)を選択

### 5. GitHubへの公開

**このステップのゴール**: 完成したプロジェクトをGitHubに公開し、バージョン管理を開始して、開発成果を共有可能な状態にする。AI駆動開発では何度もやり直しを重ねて品質を向上させるため、バージョン管理が開発プロセスの継続性と改善の追跡に不可欠となる。

**使用ツール**: GitHub Desktop, GitHub

- **GitHub Desktop**でローカルリポジトリの状態を確認
- リポジトリ名、説明、プライベート設定を指定してGitHubにパブリッシュ
- 公開されたリポジトリの確認と初期コミットの確認
- 開発成果の共有とバージョン管理の開始
- **継続的改善の記録**: AI駆動開発では何度も試行錯誤を重ねるため、各改善段階をコミットで記録し、品質向上の軌跡を残す

### 6. 継続的改善とブランチ戦略

**このステップのゴール**: 開発ワークフローの**任意の時点に戻って改善サイクルを回す**ことで、プロジェクトの完成度を段階的に高める。**基本はどこに戻ってもいい**という柔軟性が重要であり、AI駆動開発では何度も試行錯誤を重ねることで真の品質を実現する。

**使用ツール**: Claude Desktop, ClaudeCode, Cursor, Git, GitHub Desktop, GitHub

#### 🔄 柔軟なサイクル回しの重要性
**基本はどこに戻ってもいい**理由：
- **品質の段階的向上**: 一度の実装では完璧なコードは生まれない
- **人間の指示精度向上**: 繰り返しの改善により人間がAIに適切な指示と情報を渡せるようになる
- **ユーザー体験の最適化**: 実際の使用感を基に継続的に改善
- **技術的負債の回避**: 早期発見・早期修正による健全なコードベース維持
- **柔軟な開発プロセス**: 固定された順序ではなく、状況に応じて任意のステップに戻れる

#### 任意のステップへの戻り方（例：ClaudeCodeとCursor）

**ワークフロー1〜5の任意の時点に戻る例**:

**1. アイデア出し・方向性決定に戻る場合**
- 実装中に新しいアイデアが浮かんだ時
- 方向性を見直す必要が出てきた時
- Claude Desktopで再度アイデアを整理・発展

**2. 仕様書作成に戻る場合**
- 実装中に仕様の不備を発見した時
- 新機能の追加により仕様変更が必要になった時
- テキストエディタで仕様書を更新・修正

**3. 実装・フォルダ構造作成に戻る場合**
- 既存の実装に問題を発見した時
- 新機能の追加により構造変更が必要になった時
- ClaudeCodeで高速に再実装・修正

**4. Cursorでの詳細編集・品質向上に戻る場合**
- コードの品質向上が必要になった時
- パフォーマンス最適化が必要になった時
- Cursorで詳細な編集・最適化を実行

**5. GitHubへの公開に戻る場合**
- 新しい改善内容を公開したい時
- バージョン管理を更新したい時
- GitHub Desktopでコミット・プッシュ

#### ClaudeCode + Cursor を例としたサイクル回し

**ClaudeCode → Cursor → ClaudeCode のサイクル例**:
1. **ClaudeCode**: 新機能の基本実装
2. **Cursor**: コード品質の向上と最適化
3. **評価**: 改善点を発見
4. **ClaudeCode**: 改善案の高速実装（3に戻る）
5. **Cursor**: 再度の品質向上（2に戻る）
6. **統合**: GitHubへのコミット・プッシュ

**Cursor → ClaudeCode → Cursor のサイクル例**:
1. **Cursor**: 既存コードの詳細分析
2. **ClaudeCode**: 改善案の高速実装
3. **Cursor**: 改善されたコードの品質チェック
4. **評価**: さらなる改善点を発見
5. **ClaudeCode**: 追加改善の実装（2に戻る）
6. **Cursor**: 最終品質チェック（3に戻る）

#### サイクル回しの成功指標

- **柔軟性**: 任意のステップに戻れる自由度
- **改善頻度**: 定期的な改善サイクルの実行
- **品質向上**: コードの可読性・保守性の継続的向上
- **ユーザー満足度**: 実際の使用感に基づく改善
- **技術的負債削減**: 継続的なリファクタリングによる健全性維持

**重要**: **基本はどこに戻ってもいい**という柔軟性を持ち、人間がよく考えてAIに適切な指示と情報を渡すことで、開発効率とコード品質の両方が継続的に向上します。これによりAIを意図通りに動かしながら、固定された順序ではなく状況に応じて任意のステップに戻って改善サイクルを回すことが、AI駆動開発の成功の鍵です。

## AI(LLM)開発手法の実践例
- **Claude Desktop**: 開発前のアイデア出し・方向性決定（Grok3も併用）
- **ClaudeCode**: 具体的な実装・フォルダ構造作成
- **FilesystemMCP**: Claude Desktopでのフォルダ・ファイル操作の自動化
- **BlendrMCP**: Claude DesktopでのBlender統合・3Dモデリング支援
  - **[Honeycomb_Coaster - BlendrMCP活用例](https://github.com/tomomo086/Honeycomb_Coaster)** - 3Dモデリングプロジェクトの実践例
  - **幾何学図形・用途限定**: 基本的な幾何学図形の生成や用途が限定的な場面で効果を発揮
  - **アドオン連携**: SketchfabやHyper3Dなどのアドオンとの連携により、より高度な機能を活用可能
  - **デザイン適性**: 機械設計よりもキャラクターや有機的なデザインの作成に適している
- **段階的開発**: アイデア→仕様書→実装の流れ





## Claude二刀流活用 + Cursor統合
- **ClaudeCode**: コマンドライン統合開発
- **Claude Desktop**: FilesystemMCP による自動化
- **FilesystemMCP**: フォルダ・ファイルの作成・編集・操作を自動化
- **BlendrMCP**: Blender統合・3Dモデリング支援・自動化
- **Cursor**: 詳細編集・品質向上・最適化作業
  - **Reject/Accept機能**: 細かな段階的修正が可能
  - **複数AI(LLM)対応**: Claude、Gemini、その他のAI(LLM)と使い分け可能

## 統合開発環境
- **WSL2 + Docker**統合開発環境
- **Git + GitHub**連携設定
- **実用レベル**の統合ワークフロー

## 📊 検証・評価

### 開発効率改善実績
- バイブコーディングの品質向上と効率化を実現
- 自動化によるヒューマンエラーの削減
- 実用レベルでの継続運用中





